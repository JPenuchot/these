\documentclass[../paper.tex]{subfiles}
\begin{document}

\section{constexpr parsing for high performance computing}
\label{lbl:math-parsing}

In the previous section we demonstrated that it is possible to generate code
from \constexpr parsing results. We now want to implement a similar process for
a more complex language. As the most common use case for traditional
\cpp \dsel is to implement numerical computation libraries, our next example
provides a compile time parser for a mathematical language.\\

To do so, we implement a \constexpr parser based on the Shunting
yard algorithm (Dijsktram 1961). This algorithm is fairly simple to implement
and generates a Reverse Polish notation (RPN) (≈Åukasiewicz, 1951) representation
of a mathematical formula. The parser is able to handle parenthesis,
function calls, and variable identifiers.

For the code generation part, we will be using a high performance
code generation library called Blaze \cite{blazelib}, which we will
briefly introduce.

\subsection{The Blaze library}

The Blaze library allows the generation of high performance programs for
linear algebra computing. It provides a very high level interface, thanks
to its DSEL based on \cpp syntax though operator overloading.

It relies on expression templates, which consists in building
type representations of mathematical expressions at compile time.
These compile time expressions are then transformed into heavily optimized code.

To better understand how Blaze works, we will walk though a short example.

% Build an expression

\begin{lstlisting}[
  language=C++,
  caption=Building a Blaze expression template,
  label=lst:blaze-example-expression
]{}
blaze::DynamicMatrix<float> a(8192, 8192, 1.f);
blaze::DynamicVector<float> b(8192, 2.f);
blaze::DynamicVector<float> c(8192, 3.f);

auto expr = a * b + c; // No compute happens here
\end{lstlisting}

We first begin by defining a matrix and two vectors.
We want to perform a matrix-vector product as well as a vector-vector addition.
For that we define \lstinline{a}, \lstinline{b}, and \lstinline{c},
and generate an expression template that will be stored in the \lstinline{expr}
variable as shown in listing \ref{lst:blaze-example-expression}.

Note that this code does not perform any mathematical computation,
but only the generation of an expression template at compile time.
The use of the \lstinline{auto} keyword allows us to store the expression
template generated by the expression at compile time.

\begin{lstlisting}[
  language=C++,
  caption=Blaze expression template,
  label=lst:blaze-example-type
]{}
blaze::DVecDVecAddExpr<
  blaze::DMatDVecMultExpr<
    blaze::DynamicMatrix<float>,
    blaze::DynamicVector<float>>,
  blaze::DynamicVector<float>, false /* Transpose flag */>
\end{lstlisting}

The expression template is a tree describing the whole computation
stored as a type hierarchy as shown in listing \ref{lst:blaze-example-type}.
We must assign it to a Blaze container to evaluate and store
the result of the computation.

\begin{lstlisting}[
  language=C++,
  caption=Evaluating a Blaze expression template,
  label=lst:blaze-example-compute
]{}
blaze::DynamicVector<float> res = expr; // Compute happens here
\end{lstlisting}

Listing \ref{lst:blaze-example-compute} shows the assignment of \lstinline{expr}
to a Blaze dynamic vector object called \lstinline{res}.
This assignment triggers the code generation through the overloaded
\lstinline{assign} function of Blaze.
The content of \lstinline{res} after the assignment is a vector of 8192 elements
of value 16387.

\cpp overload resolution allows the library to select an optimal evaluation
strategy for each subexpression of the formula using:

\begin{itemize}
\item the use of SIMD intrinsics,
\item lazy evaluation for fused element-wise operations,
\item use of BLAS and LAPACK kernels for non-trivial computations,
\item and parallelism through libraries such as OpenMP or HPX\cite{hpx}.
\end{itemize}

As we can see, Blaze's API remains limited to what the \cpp syntax allows
through operator overloading. While it is still very user friendly,
parsing the \LaTeX{} math syntax could bridge another gap towards
seamless transition from \LaTeX{} math formulas to
highly optimized math computation programs.

The following subsections will detail how to implement a \constexpr parser
for a subset of \LaTeX{} math, and how to use its result to generate
high performance code with Blaze.

\subsection{A constexpr Shunting Yard parser}

The Shunting yard algorithm is fairly simple to implement. It only requires an
operator stack and an output queue, and its time and space complexity are
linear. Its output has an interesting property: the Reverse Polish notation
describes a hierarchy using the position of the tokens in an array, and
therefore an array of tokens is all it takes to represent a mathematical formula.
In other words: the representation is already serialized, making it trivially
transformable into a non-type template parameter compatible representation for
code generation.\\

We won't focus on parsing function implementation details as
\constexpr parsing functions are already covered with the BF parser, however
we'll look at the input and output data structures in detail in
listing \ref{lst:sy-typedefs}.

\lstinputlisting[
  language=C++,
  firstline=19,
  lastline=37,
  caption=Shunting Yard type definition examples,
  label=lst:sy-typedefs
]{poacher/shunting-yard/include/shunting_yard.hpp}

Other tokens are defined following the same pattern:

\begin{itemize}
\item \lstinline{function_t}, \lstinline{lparen_t} and \lstinline{rparen_t}.
\item \lstinline{operator_t}, containing a precedence level and associativity.
\item \lstinline{constant_t}, containing an unsigned integer.
\end{itemize}

An arbitrary token can then be defined as a \lstinline{std::variant} of these
types (listing \ref{lst:sy-token_t-typedef}). The Shunting yard implementation
can be fed with token definitions in order to parse various algebras
(listing \ref{lst:sy-token_specification_t-typedef}). Finally, the parsing result
type is defined as a \lstinline{std::vector} of \lstinline{token_t} elements.

\begin{lstlisting}[
  language=C++,
  caption=\lstinline{token_t} definition,
  label=lst:sy-token_t-typedef
]{}
using token_t = std::variant<failure_t, variable_t, function_t,
  operator_t, lparen_t, rparen_t, constant_t>;
\end{lstlisting}

\lstinputlisting[
  language=C++,
  firstline=110,
  lastline=116,
  caption=\lstinline{token_specification_t} definition,
  label=lst:sy-token_specification_t-typedef
]{poacher/shunting-yard/include/shunting_yard.hpp}

\subsection{Reverse polish notation backend}

The Reverse Polish notation has interesting properties for code generation.
Reading a formula in this format consists in reading it in order, stacking
operands and operating on the stacked operands whenever an operator or a
function is encountered. For example if we have \lstinline{2 3 +}, we will stack
\lstinline{2} then \lstinline{3}, and when the \lstinline{+} operator is
encountered it will be called on the operands, leaving the result in the stack,
\ie the value \lstinline{5}.
In our case, the tokens won't be just numbers and operators but variable and
function identifiers as well, and the results won't be just numeric values but
functions. First, we need to define a \constexpr parsing function for an
arbitrary algebra based on the \constexpr Shunting yard parsing function
\ie \lstinline{parse_to_rpn}.\\

The \lstinline{parse} function (listing \ref{lst:sy-sa-parse}) is
essentially a driver function for \lstinline{parse_to_rpn}. It prints the
parsing result for debugging when called outside of a constant evaluation.
The \lstinline{std::vector} of tokens has to be turned into an
\lstinline{std::array} with the same technique that is used in the NTTP backend
of the BF metacompiler to be used as a non-type template parameter for code
generation.\\

The \lstinline{codegen} function template is simple: as variable or number tokens
are being read in order, they are converted into function operands and stored
into a stack using a tuple. Operands are consumed into other function operands
when a function or operator token is being read. In the case of our algebra,
the final result is a function that takes two polymorphic input variables
\lstinline{x} and \lstinline{y} and performs the calculation represented by the
formula.

\lstinputlisting[
  language=C++,
  firstline=14,
  lastline=58,
  caption=\lstinline{parse} definition,
  label=lst:sy-sa-parse
]{poacher/shunting-yard/include/rubbish_algebra.hpp}

Let's have a look at how to use it.
In the listing \ref{lst:sy-sa-use}, the formula is first parsed into a function,
and the function itself binds the \lstinline{x} and \lstinline{y} variables to
its first and second arguments respectively. Then these variables are replaced
with \lstinline{vector_x} and \lstinline{vector_y} as it is called in the range
for loop, generating the expression template for the expression represented by
the formula.

\lstinputlisting[
  language=C++,
  firstline=10,
  lastline=28,
  caption=Code generation using \constexpr mathematical formula parsing with Blaze,
  label=lst:sy-sa-use
]{poacher/shunting-yard/src/rubbish_algebra.cpp}

\end{document}
