\documentclass[../main]{subfiles}
\begin{document}

\section{Language constructs of \cpp metaprogramming}

In this section I will cover the constructs of \cpp metaprogramming.
Metaprograms are defined as programs that take code as input and/or output,
therefore I will categorize metaprogramming constructs as:
those used for input and output,
and those that enable compile time computing.

This distinction will be important to explain the work presented in
this thesis, as it focuses a lot on methods to translate
compile time compute results into \cpp programs.

\subsection{Input and output of metaprograms}

\subsubsection{Templates}

Templates are the cornerstone of the \cpp metaprogramming model.
They are the main \cpp mechanism to generate structures, functions,
or even variables from types or values known at compile time.
They were originally meant to be used for implementing generic types,
but over time the extension of their features made them Turing complete.

\paragraph{Different kinds of templates}

\cpp templates offer ways to output code for both data structures
and functions.

\begin{itemize}
\item Type templates

\begin{lstlisting}[
  language=c++,
  caption=Type template example,
  label=lst:type-template-example
]{}
/// Generic anotated type
template <typename T> struct named_value_t {
  std::string name;
  T value;
};
\end{lstlisting}

\begin{lstlisting}[
  language=c++,
  caption=Type alias template example,
  label=lst:type-alias-template-example
]{}
/// Alias template for nested named value
template <typename T>
using nested_named_value_t =
    named_value_t<named_value_t<T>>;
\end{lstlisting}

Templates can be used with type aliases too, as shown in
listing \ref{lst:type-alias-template-example}.

\item Function templates

\begin{lstlisting}[
  language=c++,
  caption=Function template example,
  label=lst:function-template-example
]{}
/// Returns a value annotated with
/// its string representation
template <typename T>
named_value_t<T> make_named_value(T value) {
  return named_value_t<T>(std::to_string(value),
                          std::move(value));
}
\end{lstlisting}

\item Variable templates

\begin{lstlisting}[
  language=c++,
  caption=Variable template example,
  label=lst:variable-template-example
]{}
/// Returns the default value of T annotated with
/// its string representation
template <typename T>
named_value_t<T> annotated_default_v =
    make_named_value(T{});

named_value_t<int> val = annotated_default_v<int>;
\end{lstlisting}

\end{itemize}

\paragraph{Different kinds of parameters}

\begin{itemize}
\item Type parameters
\item Non-type template parameters (\nttp)
\item Parameter packs
\end{itemize}

\paragraph{Advanced \cpp template mechanisms}

\begin{itemize}
\item Substitution failure is not an error (\sfinae)
\item Template specialization
\end{itemize}

\subsubsection{Overloading}

\subsection{Compile time logic}

\subsubsection{\Tmp and constant evaluation}

\begin{itemize}
\item Computation using types
\item Computation using values
\end{itemize}

\subsubsection{Constexpr functions}

\begin{itemize}
\item \constexpr functions
\item \constexpr memory allocation
\end{itemize}

The use of \constexpr functions for compile time programming is preferable
for many reasons: familiar to most \cpp developers (and therefore more
maintainable), it allows the use of types to enforce semantics properly
as opposed to type-based metaprogramming, and it scales much better than \tmp.

% Templates allow types, variables, and functions to be generated from
% compile time parameters. These parameters used to be only types,
% but over time \cpp evolved to allow developers to use typed values
% and parameter packs.
%
% Function overloading allows several functions to bear the same name
% as long as they cannot be invoked with parameters of the same type.
% This allows selection of code paths to happen at compile time.
%
% Although these two mechanisms are enough to build very capable
%
% \subsection{
%   Templates
% }
%
% \subsubsection{
%   Different kinds of templates
% }
%
% \paragraph{
%   Types
% }
%
% An example:
%
% \begin{lstlisting}[
%   language=c++,
%   caption=Some example
% ]
% template<typename T> struct toto_t {};
% \end{lstlisting}
%
% \paragraph{
%   Functions
% }
%
% An example:
%
% \begin{lstlisting}[
%   language=c++,
%   caption=Some example
% ]
% template<typename T> struct toto_t {};
% \end{lstlisting}
%
% \paragraph{
%   Variables
% }
%
% An example:
%
% \begin{lstlisting}[
%   language=c++,
%   caption=Some example
% ]
% template<typename T> struct toto_t {};
% \end{lstlisting}
%
%
% \subsubsection{
%   Different kinds of parameters
% }
%
% ...
%
% \subsection{Overloading}
%
% \subsection{Constant evaluation}
%
% \subsection{\lstinline{if constexpr}}
%
% \subsection{Parameter packs}
%
% \subsection{Constexpr functions and variables}

% TODO: Integrate that subsection better

\subsection{
  Template Metaprogramming
}

\cpp template metaprogramming \cite{abrahams:2004} is a technique based on the
use of the template type system of \cpp to perform arbitrary computation at
compile time. This property of \cpp templates is due to the fact they
define a Turing-complete sub-language manipulating types and integral constants
at compile time \cite{unruh:1994}. Due to the fact that template code generation
is performed at compile time, uses constants and supports pattern-matching and
recursion thanks to template partial specialization, it can also be looked
at as a pure functional language \cite{haeri:2012}.

Templates are an interesting technique for generative programming. As they
are Turing-complete, one can design a set of template metaprograms acting as a
\dsl compiler run at compile time and generating temporary \cpp code fragment as
an output. The resulting temporary source code is then merged with the rest of
the source code and finally processed by the classic compilation process.
Through this technique, compile time constants, data structures and complete
functions can be manipulated. The execution of metaprograms by the compiler
enables the library to implement domain-specific optimizations that lead to a
complete domain oriented code generation. Such a technique can be hosted by
several languages featuring metaprogramming features (incidental or by design)
like D \cite{template:dlang}, Haskell \cite{sheard:2002} and
OCaml \cite{serot:2008}.

\begin{lstlisting}[
  language=C++,
  caption=Example of compile time computation using C++ templates,
  label=lst:basic-tmp
]{}
// Template type accepting an integer
// as a non-type template parameter
template <unsigned N> struct fibonacci_t;

// General definition
template <unsigned N> struct fibonacci_t {
  static constexpr unsigned value =
      fibonacci_t<N - 2>::value + fibonacci_t<N - 1>::value;
};

// Specialization for cases 0 and 1
template <> struct fibonacci_t<0> {
  static constexpr unsigned value = 0;
};

template <> struct fibonacci_t<1> {
  static constexpr unsigned value = 1;
};

std::array<int, fibonacci_t<5>::value> some_array;
\end{lstlisting}

Listing \ref{lst:basic-tmp} shows basic principles of \cpp template
metaprogramming. The \lstinline{fibonacci_t} type template accepts a
\textit{Non-Type Template Parameter} (\nttp, \ie a template parameter that is
a regular value instead of a type) called $N$, and exposes the
$N\textsuperscript{th}$ element of the Fibonacci series as its
\lstinline{value} static member. The template has 3 definitions:
a generic one to calculate elements for $N > 1$,
and two specializations for elements of ranks $0$ and $1$.

Note that the \lstinline{value} field is specified as \constexpr.
It indicates that a variable or function can be used in compile time
expressions.
We will talk about \constexpr in detail in \ref{lbl:constexpr-programming}.

\end{document}
