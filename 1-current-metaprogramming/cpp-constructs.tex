\documentclass[../main]{subfiles}
\begin{document}

\section{
  Language constructs of \cpp metaprogramming
}

In this section I will cover the constructs of \cpp metaprogramming.
Metaprograms are defined as programs that take code as input and/or output,
therefore I will categorize metaprogramming constructs as:
those used for input and output,
and those that enable compile time computing.

This distinction will be important to explain the work presented in
this thesis, as it focuses a lot on methods to translate
compile time compute results into \cpp programs.

\subsection{
  Input and output of metaprograms
}

\subsubsection{
  Template metaprogramming
}

\cpp template metaprogramming \cite{abrahams:2004} is a technique based on the
use of the template type system of \cpp to perform arbitrary computation at
compile time. This property of \cpp templates is due to the fact they
define a Turing-complete sub-language manipulating types and integral constants
at compile time \cite{unruh:1994}. Due to the fact that template code generation
is performed at compile time, uses constants and supports pattern-matching and
recursion thanks to template partial specialization, it can also be looked
at as a pure functional language \cite{haeri:2012}.

Templates are an interesting technique for generative programming. As they
are Turing-complete, one can design a set of template metaprograms acting as a
\gls{dsl} compiler run at compile time and generating temporary \cpp code
fragment as an output. The resulting temporary source code is then merged with
the rest of the source code and finally processed by the classic
compilation process. Through this technique, compile time constants,
data structures and complete functions can be manipulated.
The execution of metaprograms by the compiler enables the library to implement
domain-specific optimizations that lead to a complete domain oriented
code generation. Such a technique can be hosted by several languages featuring
metaprogramming features (incidental or by design) like D \cite{template:dlang},
Haskell \cite{sheard:2002} and OCaml \cite{serot:2008}.

\begin{lstlisting}[
  language=C++,
  caption=Example of compile time computation using C++ templates,
  label=lst:basic-tmp
]{}
// Template type accepting an integer
// as a non-type template parameter
template <unsigned N> struct fibonacci_t;

// General definition
template <unsigned N> struct fibonacci_t {
  static constexpr unsigned value =
      fibonacci_t<N - 2>::value + fibonacci_t<N - 1>::value;
};

// Specialization for cases 0 and 1
template <> struct fibonacci_t<0> {
  static constexpr unsigned value = 0;
};

template <> struct fibonacci_t<1> {
  static constexpr unsigned value = 1;
};

std::array<int, fibonacci_t<5>::value> some_array;
\end{lstlisting}

Listing \ref{lst:basic-tmp} shows basic principles of \cpp template
metaprogramming. The \lstinline{fibonacci_t} type template accepts a
\gls{nttp} called $N$, and exposes the
$N\textsuperscript{th}$ element of the Fibonacci series as its
\lstinline{value} static member. The template has 3 definitions:
a generic one to calculate elements for $N > 1$,
and two specializations for elements of ranks $0$ and $1$.

\paragraph{Different kinds of templates}

\cpp templates offer ways to output code for both data structures
and functions.

\begin{itemize}
\item Type templates

\begin{lstlisting}[
  language=c++,
  caption=Type template example,
  label=lst:type-template-example
]{}
/// Generic anotated type
template <typename T> struct named_value_t {
  std::string name;
  T value;
};
\end{lstlisting}

\begin{lstlisting}[
  language=c++,
  caption=Type alias template example,
  label=lst:type-alias-template-example
]{}
/// Alias template for nested named value
template <typename T>
using nested_named_value_t =
    named_value_t<named_value_t<T>>;
\end{lstlisting}

Templates can be used with type aliases too, as shown in
listing \ref{lst:type-alias-template-example}.

\item Function templates

\begin{lstlisting}[
  language=c++,
  caption=Function template example,
  label=lst:function-template-example
]{}
/// Returns a value annotated with
/// its string representation
template <typename T>
named_value_t<T> make_named_value(T value) {
  return named_value_t<T>(std::to_string(value),
                          std::move(value));
}
\end{lstlisting}

\item Variable templates

\begin{lstlisting}[
  language=c++,
  caption=Variable template example,
  label=lst:variable-template-example
]{}
/// Returns the default value of T annotated with
/// its string representation
template <typename T>
named_value_t<T> annotated_default_v =
    make_named_value(T{});

named_value_t<int> val = annotated_default_v<int>;
\end{lstlisting}

\end{itemize}

\paragraph{Different kinds of parameters}

\begin{itemize}
\item Type parameters
\item \gls{nttp}
\item Parameter packs
\end{itemize}

\paragraph{Advanced \cpp template mechanisms}

\begin{itemize}
\item \gls{sfinae}
\item Template specialization
\item Parameter packs
\end{itemize}

\subsubsection{
  Overloading
}

\subsection{
  Compile time logic
}

\subsubsection{
  \acrlong{tmp} and constant evaluation
}

\begin{itemize}
\item Computation using types
\item Computation using values
\end{itemize}

\subsubsection{
  Constexpr functions
}

\begin{itemize}
\item \gls{constexpr} functions
\item \gls{constexpr} memory allocation
\end{itemize}

The use of \gls{constexpr} functions for compile time programming is preferable
for many reasons: familiar to most \cpp developers (and therefore more
maintainable), it allows the use of types to enforce semantics properly
as opposed to type-based metaprogramming, and it scales much better than
\gls{tmp}.

% Templates allow types, variables, and functions to be generated from
% compile time parameters. These parameters used to be only types,
% but over time \cpp evolved to allow developers to use typed values
% and parameter packs.
%
% Function overloading allows several functions to bear the same name
% as long as they cannot be invoked with parameters of the same type.
% This allows selection of code paths to happen at compile time.
%
% Although these two mechanisms are enough to build very capable
%
% \subsection{
%   Templates
% }
%
% \subsubsection{
%   Different kinds of templates
% }
%
% \paragraph{
%   Types
% }
%
% An example:
%
% \begin{lstlisting}[
%   language=c++,
%   caption=Some example
% ]
% template<typename T> struct toto_t {};
% \end{lstlisting}
%
% \paragraph{
%   Functions
% }
%
% An example:
%
% \begin{lstlisting}[
%   language=c++,
%   caption=Some example
% ]
% template<typename T> struct toto_t {};
% \end{lstlisting}
%
% \paragraph{
%   Variables
% }
%
% An example:
%
% \begin{lstlisting}[
%   language=c++,
%   caption=Some example
% ]
% template<typename T> struct toto_t {};
% \end{lstlisting}
%
%
% \subsubsection{


%   Different kinds of parameters
% }
%
% ...
%
% \subsection{
%   Overloading
% }
%
% \subsection{
%   Constant evaluation
% }
%
% \subsection{
%   \lstinline{if constexpr}
% }
%
% \subsection{
%   Parameter packs
% }
%
% \subsection{
%   Constexpr functions and variables
% }


\end{document}
