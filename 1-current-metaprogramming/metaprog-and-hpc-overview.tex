\documentclass[../main]{subfiles}
\begin{document}

% - SotA metaprog (Can't read)
%   - C++ (Can't read)
%   - Reflection
%   - Can't read

\section{
  Metaprogramming styles and languages
}

% TODO: Des p'tits exemples

Metaprogramming is not an new concept. It perpetuates itself in contemporary
languages, with some being more widespread than others.

\paragraph{C and C++ preprocessor}

\paragraph{Lisp macros}

\paragraph{MetaOCaml} \cite{metaocaml} implements quoting and splicing
\ie the ability to essentially copy and paste expressions,
as well as staged compilation to evaluate statements at compile-time.
This enables code generation to occur both at runtime and at compile-time.

\paragraph{DLang} more or less extends the \cpp Metaprogramming model.
It leverages templates and compile time function evaluation just like
its predecessor.

Compile-time evaluation is much more permissive and mixins enable to generate
code in a more direct way than \cpp. Dlang mixins allow injecting code in
functions and structures in two ways: using template mixins
which are pre-parsed constructs that can be injected later,
as well as string mixins that allow strings containing Dlang code
to be compiled and inserted directly into programs.

\paragraph{Rust} proposes metaprogramming through macros, generics, and traits.

Rust macros are more powerful than those proposed in C and \cpp.
They have a

\paragraph{Braid} \cite{braid} is language that implements metaprogramming
through multi-staged programming (like MetaOCaml) for heterogeneous real-time
3D graphics. It is however unmaintained.

\paragraph{Julia} \cite{julia} is a dynamic language that uses the LLVM

\paragraph{Terra}

Terra\cite{terra} implements a very explicit metaprogramming model.
The language is based on LUA, and exploits the dynamic nature of the language
together with LLVM \gls{jit} compilation to allow code generation
to happen at runtime.
It implements multi-staged compilation and splicing just like MetaOCaml.

Additionally, Terra can be embedded in other languages through its C API.
Overall it is a very versatile and experimental take on metaprogramming,
but the lack of interoperability with \cpp templates makes it hard to justify
its use for \gls{hpc} applications.

As we will see in section \ref{lbl:meta-cpp}, \gls{gpu} computing libraries
rely heavily on \cpp metaprogramming to provide building blocks for
portable high performance compute kernels.

\end{document}
