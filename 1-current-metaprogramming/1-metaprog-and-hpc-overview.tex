\documentclass[../main]{subfiles}
\begin{document}

% - SotA metaprog (Can't read)
%   - C++ (Can't read)
%   - Reflection
%   - Can't read

\section{
  Metaprogramming styles and languages
}

Metaprogramming is not an new concept. It perpetuates itself in contemporary
languages, with some being more widespread than others.

I will focus on partial specialization, which consists in separating
static parts of programs from the dynamic parts in order to interpret
the static parts at compile time and leave only the dynamic parts for the
program's execution \cite{10.1145/243439.243447, 10.1023/A:1010095604496}.
When the target architecture is known during the compilation, partial evaluation
can be leveraged to optimize critical parts of high performance applications
by specializing (or tuning) these parts for it.

In \cpp, templates serve as an interface for partial specialization.
However, many other ways to implement it exist across a wide range of languages
spanning more than half a century.

% TODO: Des p'tits exemples (voir le livre de Joel)

% TODO: Citer https://hal.science/hal-01835202/document
% - Voir chapitre sur le preprocesseur: https://theses.fr/2014PA112092
%   repartir du 2.1 pour l'evaluation partielle et les beta-reductions
% - Voir 2.1.1: eval partielle
% - Voir 2.1.2.2
% - Citations 26 et 33

\begin{itemize}
\item
\textbf{The C and C++ preprocessor} acts as rudimentary token manipulation stage
that was not originally made for metaprogramming, but it can be hacked
to emulate

\item
\textbf{Lisp macros}
are known for being one of the oldest, yet one of the most powerful
examples among all metaprogramming paradigms. The List macros, as opposed to
C and \cpp macros, can make complete use of the Lisp language itself.

The Lisp-lang \cite{lisp-lang-macros} website provides a code example of
the definition of a \lstinline{while} macro, which

\begin{lstlisting}[
  language={lisp},
  caption={Definition of the \lstinline{while} Lisp macro}
]{}
(defmacro while (condition &body body)
  `(loop while ,condition do (progn ,@body)))
\end{lstlisting}


\item
\textbf{MetaOCaml} \cite{metaocaml} implements quoting and splicing
\ie the ability to essentially copy and paste expressions,
as well as staged compilation to evaluate statements at compile-time.
This enables code generation to occur both at runtime and at compile-time,
and extends OCaml's partial evaluation capabilities.


% TODO: cite source: https://okmij.org/ftp/meta-programming/tutorial/
\begin{lstlisting}[
  language=caml
]{}
let rec spower : int -> int code -> int code =
  fun n x ->
    if n = 0 then .<1>.
    else if n mod 2 = 0
      then .< square .~(spower (n/2) x) >.
      else .<.~x * .~(spower (n-1) x)>.

let spowern : int -> (int -> int) code =
   fun n -> .<fun x -> .~(spower n .<x>.)>.;;
\end{lstlisting}

\item
\textbf{DLang} more or less extends the \cpp Metaprogramming model.
It leverages templates and compile time function evaluation just like
its predecessor.

Compile-time evaluation is much more permissive and mixins enable to generate
code in a more direct way than \cpp. Dlang mixins allow injecting code in
functions and structures in two ways: using template mixins
which are pre-parsed constructs that can be injected later,
as well as string mixins that allow strings containing Dlang code
to be compiled and inserted directly into programs.

% TODO: Exemple

\item
\textbf{Rust} proposes metaprogramming through macros, generics, and traits.
In a similar way to Lisp macros, Rust macros can use the host language
as a whole. Additionally, bits of code can explicitely be parsed and reflected
upon at compile time.

Here we can find an example taken from The Rust Programming Language
book \cite{rust-book} where a simplified version of the \lstinline{vec!} macro,
which initializes a vector and pre-fills it with a static number of values,
is defined:

\begin{lstlisting}[
  language=rust
]{}
#[macro_export]
macro_rules! vec {
  ( $( $x:expr ),* ) => {
    {
      let mut temp_vec = Vec::new();
      $(
        temp_vec.push($x);
      )*
      temp_vec
    }
  };
}
\end{lstlisting}

\item
\textbf{Terra}

Terra\cite{terra} implements a very explicit metaprogramming model.
The language is based on LUA, and exploits the dynamic nature of the language
together with LLVM \gls{jit} compilation to allow code generation
to happen at runtime.
It implements multi-staged compilation and splicing just like MetaOCaml.

Additionally, Terra can be embedded in other languages through its C API.
Overall it is a very versatile and experimental take on metaprogramming,
but the lack of interoperability with \cpp templates makes it hard to justify
its use for \gls{hpc} applications.

% TODO: Exemple

\item
\textbf{LGEN}

LGEN\cite{hpcs15}:
a compiler that produces performance-optimized
basic linear algebra computations on matrices
of fixed sizes with or without structure composed
from matrix multiplication, matrix addition, matrix
transposition, and scalar multiplication. Based on
polyhedral analysis using CLoog, the generated code
outperforms MKL and Eigen.

% TODO: Combiner et dire que ces 2 langages sont d'autres exemples de metaprog

\item
\textbf{Braid} \cite{braid} is language that implements metaprogramming
through multi-staged programming (like MetaOCaml) for heterogeneous real-time
3D graphics. It is however unmaintained.

\item
\textbf{Julia} \cite{julia} is a dynamic language that uses the LLVM

\end{itemize}

\end{document}
