\documentclass[../main]{subfiles}
\begin{document}

% - SotA metaprog (Can't read)
%   - C++ (Can't read)
%   - Reflection
%   - Can't read

In this state of the art I will first give an overview of metaprogramming in
historic and contemporary languages. Then I will focus on the state of the art
of \cpp metaprogramming, and notable high performance computing libraries as they
are essential for the scope of my thesis.

\section{
  Metaprogramming styles and languages
}

\subsection{A short history of metaprogramming}

\subsection{Metaprogramming in contemporary languages}

Metaprogramming perpetuates itself in contemporary languages,
with some being more widespread than others.

\paragraph{MetaOCaml}

MetaOCaml\cite{metaocaml} implements quoting and splicing
\ie the ability to essentially copy and paste expressions,
as well as staged compilation to evaluate statements at compile-time.
This enables code generation to occur both at runtime and at compile-time.

\paragraph{DLang}

DLang more or less extends the metaprogramming model accidentally proposed
by \cpp. It leverages templates and compile time function evaluation just like
its predecessor, but with a much more permissive approach than its predecessor.


\paragraph{Rust}

Rust proposes metaprogramming through generics, macros and traits.
Generics are similar to \cpp templates, although

\paragraph{Braid}

\paragraph{Terra}

Terra\cite{terra} implements a very explicit metaprogramming model.
The language is based on LUA, and exploits the dynamic nature of the language
together with LLVM JIT compilation to allow code generation
to happen at runtime.
It implements multi-staged compilation and splicing just like MetaOCaml.

Additionally, Terra can be embedded in other languages through its C API.
Overall it is a very versatile and experimental take on metaprogramming,
but the lack of interoperability with \cpp templates makes it hard to justify
its use for HPC applications.

As we will see in section \ref{lbl:meta-cpp}, GPU computing libraries
rely heavily on \cpp metaprogramming to provide building blocks for
portable high performance compute kernels.

\section{
  Metaprogramming and HPC in C++
}
\label{lbl:meta-cpp}

\subsection{Core and application-specific libraries}

As previously said \cpp templates can be seen as a functional language.
Over time a range of libraries emerged, aiming to provide functionalities
similar to regular language such as containers and algorithms for use in
template metaprograms. Notable examples of such libraries are MPL\cite{mpl},
Brigand\cite{brigand}, and mp11\cite{mp11}.

Libraries for more specific uses were also implemented, such as
Spirit\cite{spirit} for writing parsers (not for compile time parsing),
Compile Time Regular Expressions (CTRE)\cite{ctre}
for compiling regular expressions,
and Compile Time Parser Generator(CTPG)\cite{ctpg}
for generating LR1 parsers (also not for compile time parsing).

The benefits of metaprogrammed libraries are:

\begin{itemize}

\item Performance: notably in the case of CTRE.
Regular expressions are usually interpreted at runtime,
which adds a measurable overhead to text processing.
CTRE shows leading performance, on par with Rust's regex library
which also works by compiling regular expressions.

\item Language integration: since these are \cpp libraries,
their APIs can take advantage of \cpp operator overloading and lambdas.
In CTPG, these are used to provide a domain-specific language that is close to
what parser generators like YACC or Bison provide,
though it is still regular \cpp code which can be put inside any function body.
Using a \cpp API makes these libraries easier to learn
as the syntax is already familiar to their users.

\item Streamlined toolchain: as they only require to be included as headers.
This avoids complicating compilation toolchains by requiring additional programs
to be installed and integrated to the build system.

\end{itemize}

\subsection{High performance computing libraries}

There are many \cpp HPC libraries that use metaprogramming to achieve
high performance while offering high level APIs.

\begin{itemize}
\item
Eigen\cite{eigen} is the first major \cpp library to implement
expression templates for the generation of high performance math computing.


% TODO: Example

\item
Blaze\cite{blazelib} is a successor of Eigen that implements so-called
"Smart Expression Templates" which extends upon the concept of
expression templates implemented by Eigen. It aims to provide a more performant
and extensible HPC library. However, Eigen is not set in stone
and its designed has since been updated.

% TODO: Example

\item
NT2\cite{nt2}

% TODO: Example

\item
EVE\cite{eve} provides generic abstractions over SIMD instructions,
as well as SIMD-optimized generic algorithms.

% TODO: Example

\item
HPX\cite{hpx}

% TODO: Example

\item Thrust \cite{thrust} and CUB \cite{cub}

% TODO: Example

\end{itemize}

\section{
  Conclusion
}

\begin{itemize}
\item Metaprogramming isn't a new idea

\item Some languages provide advanced metaprogramming capabilities

\item \cpp has solid metaprogramming constructs, and a complete HPC ecosystem
(libraries, compilers, etc.)
\end{itemize}

\end{document}
