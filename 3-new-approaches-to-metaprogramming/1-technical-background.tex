\documentclass[../main]{subfiles}
\begin{document}

% TODO: Rework this as most of this stuff is introduced in the
% state of the art section

\section{
  A technical background of C++ metaprogramming and DSELs
}

By definition, a Domain-Specific Language (\dsl) is a computer language
specialized to a particular application domain, contrary to a general-purpose
language, which is broadly applicable across domains, and lacks specialized
features for a particular domain. Domain Specific Embedded Languages (\dsels)
are a subclass of \dsl that rely on an existing general-purpose language to host
it. \dsels then reuse the host language syntax and tool ecosystem to be compiled
or interpreted.

In \cpp, the compile time process of generating new code is
\textbf{Template Metaprogramming} to ensure performance and correctness.

\subsection{
  Constexpr programming
}
\label{lbl:constexpr-programming}

Expressions that generate results for use at compile time are called
constant expressions. In \cpp11, the \constexpr keyword was introduced
to qualify functions or variables that may be used in constant expressions.
Consequently, regular functions and variables became usable for the evaluation
of non-type template parameters.

However not all functions and variables can be qualified as \constexpr,
and not all constant expression results can be used as \nttps.

Since the introduction of the \constexpr specifier, the requirements on
functions for being \constexpr specifiable have constantly been relaxed as new
\cpp standards were adopted. In \cpp20, notable changes made dynamic memory
allocations\cite{constexpr-memory} and virtual \constexpr function
calls\cite{virtual-constexpr} allowed in compile time \constexpr function
executions.

These two additions make dynamic memory and heritage-based polymorphism
possible in \constexpr functions. Therefore more regular \cpp code can be
executed at compile time, including parsers for arbitrary languages.

\paragraph{\constexpr functions} Functions that are \constexpr qualified can
still be used in other contexts than constant evaluation happening at
compile time. In non-constant evaluation, \constexpr functions can still call
non-\constexpr functions. But in constant evaluations, \constexpr functions must
only call other \constexpr functions. This applies to methods as well.
In order to make a \cpp class or structure fully usable in constant evaluations,
its methods ---including the constructors and destructor--- must be \constexpr.

\paragraph{\constexpr variables} Variables that are \constexpr qualified can be
used in constant expressions. Note that they are different from
non-\constexpr variables used in \constexpr functions.
There are more requirements on \constexpr variables.
Their values must be literal, meaning that memory allocated in \constexpr
function bodies cannot be stored in \constexpr variables.

\paragraph{
  \constexpr memory allocation
}
Starting from \cpp20, \lstinline{std::allocate} and \lstinline{std::deallocate}
are \constexpr functions, allowing memory allocations to happen in
constant evaluations.

However \constexpr allocated memory is not transient, \ie memory allocated in
constant expressions cannot be stored in \constexpr variables, and non-type
template parameters cannot hold pointers to \constexpr allocated memory either.

Note that this restriction does not mean that data stored in \constexpr memory
cannot be passed through. There are techniques to use data in \constexpr
allocated memory

\begin{lstlisting}[
  language=C++,
  caption=Illustration of constraints on \constexpr allocated memory,
  label=lst:cx-examples
]{}
// Constexpr function generate returns a non-literal value
constexpr std::vector<int> generate() { return {1,2,3,4,5}; }

// Function template foo takes a polymorphic NTTP
template<auto bar> constexpr int foo() { return 1; }

// generate's return value cannot be stored in a constexpr variable
// or used as a NTTP, but it can be used to produce other literal

// constexpr auto a = generate();         // ERROR
constexpr auto b = generate().size();     // OK
// constexpr auto c = foo<generate()>();  // ERROR
constexpr auto d = foo<&generate>();      // OK
\end{lstlisting}

Let's have a closer look at the four assignment cases:

\begin{itemize}
\item Case \lstinline{a}: \lstinline{generate}'s return value is non-literal
      and therefore cannot be stored in a \constexpr variable.
\item Case \lstinline{b}: \lstinline{generate}'s return value is used in a
      constant expression to produce a literal value.
      Therefore the expression's result can be stored in a \constexpr variable.
\item Case \lstinline{c}: similarly to case \lstinline{a},
      \lstinline{generate}'s return value cannot be used as an \nttp because it
      is not a literal value.
\item Case \lstinline{d}: function references are allowed as \nttps.
\end{itemize}

Notice how the last example works around restrictions of \constexpr allocations
by using a generator function instead of passing the non-empty
\lstinline{std::vector<int>} value directly. This technique along with the
definition of lambdas can be used to explore more complex structures returned by
\constexpr functions such as pointer trees.

Moreover, \constexpr allocated memory being non transient does not mean that its
content cannot be transferred to \nttp compatible data structures.

\begin{lstlisting}[
  language=C++,
  caption=Transfer of data from a dynamic \lstinline{std::vector}
    to a constexpr static \lstinline{std::array},
  label=lst:cx-vector-to-array
]{}
constexpr auto generate_as_array() {
  constexpr std::size_t array_size = generate().size();
  std::array<int, array_size> res{};
  std::ranges::copy(generate(), res.begin());
  return res;
}

constexpr auto e = generate_as_array();         // OK
constexpr auto f = foo<generate_as_array()>();  // OK
\end{lstlisting}

Listing \ref{lst:cx-vector-to-array} shows how \lstinline{generate}'s result
can be evaluated into a static array. Static arrays are literal as long
as the values they hold are literal. Therefore the result of
\lstinline{generate_as_array} can be stored in a \constexpr variable or used
directly as an \nttp for code generation.

\paragraph{
  \constexpr virtual functions
}

This feature allows calls to virtual functions in constant expressions
\cite{virtual-constexpr}. This allows heritage-based polymorphism in \constexpr
programming when used with \constexpr allocation of polymorphic types.

\subsubsection{
  Cest: standard-like containers for \constexpr programming
}

With dynamic memory and virtual functions making their way to
\constexpr programming, the next logical step is to make standard \cpp
containers available in constant evaluations.
Modifying the \cpp standard to accomodate that need takes time.
However, implementing standard-like containers that are good enough
for prototyping and experimenting with \constexpr programs
can be done fast enough.

The C'est \cite{cest} library was created with this goal in mind, filling the
gap in the \cpp standard, and accommodating the need for \constexpr compatible
standard containers.
As of today most of the containers implemented in C'est are available in
up-to-date standard libraries, but it is still a useful library for
compatibility with platforms that do not have \cpp23 compatible compilers and
standard libraries such as old versions of Debian.

It was instrumental for this thesis as the research work I present here started
a long time before \cpp23 was adopted and standard libraries and compilers
started implementing it.

I contributed to its development myself by implementing a \constexpr version
of \lstinline{std::unique_ptr}. This collaboration led Joel Falcou and myself to
meet with its initiator, Paul Keir, in Glasgow and Paris.
Our collaboration also led to speak together at
Meeting \cpp 2022 \cite{meetingcpp22} where we talked about C'est and
its use cases for \constexpr programming research.

% \section{C++23 experiments for implementing EDSLs of arbitrary syntaxes}

% We explore two cases of \constexpr parser implementations for small languages
% that return abstract syntax trees using \constexpr allocated memory through
% standard containers, and backends that transform the \constexpr function results
% into programs through templates using different techniques. The use cases we
% consider are:
%
% \begin{itemize}
%   \item The Brainfuck as a Turing machine emulation language. Its main interest
%         is its large corpus of example programs.
%   \item A basic math language supporting infix operators and function calls.
% \end{itemize}

% The Poacher project was started to experiment ways to leverage \constexpr
% programming for the integration of embedded domain specific languages of
% arbitrary syntaxes. Considering the current restrictions on \constexpr allocated
% memory, going from a static string representation of a program, mathematical formula, or
% regular expression to a compiled program using \constexpr programming might not
% be trivial.

% https://www.cs.rhul.ac.uk/research/languages/csle/lookahead_backtrack.html
% https://www.boost.org/doc/libs/1_81_0/libs/spirit/doc/html/spirit/references.html
% https://github.com/antlr/antlr4

\subsection{
  \cpp Domain Specific Embedded Languages
}

\dsels in \cpp use template metaprogramming via the \textit{Expression
Template} idiom.
\textbf{Expression Templates} \cite{veldhuizen:1995,vandevoorde:2002} is a
technique implementing a form of \textbf{delayed evaluation} in
\cpp \cite{spinellis:2001}. Expression Templates are built around the
\textit{recursive type composition} idiom \cite{jarvi:1998} that allows the
construction, at compile time, of a type representing the abstract syntax tree
of an arbitrary statement. This is done by overloading functions and operators
on those types so they return a lightweight object.
The object encodes the current operation in the Abstract Syntax Tree
(AST) being built in its type instead of performing any kind of computation.
Once reconstructed, this AST can be transformed into arbitrary code fragments
using Template Metaprograms.

As of today, most \cpp EDSLs rely on \textit{Expression Templates} and therefore
are limited to the \cpp syntax. New techniques are becoming more popular through
the use of \constexpr strings to embed arbitray \dsels. One major example is
the Compile-Time Regular Expressions library (CTRE) \cite{ctre} that implements
most of the Perl Compatible Regular Expression (PCRE) syntax. However, CTRE
still relies on type-based template metaprogramming to parse regular expressions
and transform them into regular expression evaluators.

% TODO: Expose the issue clearly!!

% https://martinfowler.com/books/dsl.html

\end{document}
