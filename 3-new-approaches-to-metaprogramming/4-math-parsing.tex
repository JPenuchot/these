\documentclass[../main]{subfiles}
\begin{document}

% NOTE: The RPN notation was already introduced

\section{
  Math parsing and high performance code generation
}

Now that we have a good overview of what to

\subsection{
  The Shunting-Yard algorithm
}

As seen in \ref{lbl:codegen-from-rpn}, generating code from \gls{rpn} formulas
is a rather easy task, and converting formulas from an infix notation to a
postfix notation can be done using the Shunting Yard
algorithm \cite{shunting-yard}.

As parsing algorithms and \gls{constexpr} dynamic data representations were
already covered in \ref{lbl:bf-parsing-and-codegen}, the implementation of
the Shunting Yard algorithm will not be covered in detail here.
A thoroughly commented \gls{constexpr} implementation is available in appendix
\ref{app:shunting-yard-impl}. It features the algorithm itself, as well as
data structures it relies on, and higher order helper functions
for code generation.

The working principle of the algorithm is rather simple:
an operator and an operand stack are read in order and moved
from the input list to the output queue and the operator stack.

% TODO: High level description of the algorithm

Once again, code generation from postfix notation formulas was already covered
in \ref{lbl:codegen-from-rpn}, so we will skip straight to the use of Blaze
to generate high performance code from \gls{constexpr} formulas.

\subsection{
  Using Blaze for high performance code generation
}

All the technical aspects of high performance code generation from
\gls{constexpr} \glspl{dsel} in \cpp23 have been covered and implemented
individually so far:

\begin{itemize}
\item a \gls{constexpr} Shunting Yard parser for math formulas,
\item a code generator for \gls{rpn} formulas,
\item and an optimizing library for math computation (the Blaze library).
\end{itemize}

I will now demonstrate that all these layers can work together
as a complete high performance compilation chain for a math \glspl{dsel}.

I will start by introducing a simple demonstrator language: \gls{tml}.
It is a very basic language for simple math that can read math formulas
containing integers, \lstinline{x} and \lstinline{y} variables,
\lstinline{sin} and \lstinline{max} functions, a small set of infix operators
(\lstinline{+}, \lstinline{-}, \lstinline{*}, \lstinline{/}, and\lstinline{^}),
as well as \lstinline|{}| and \lstinline{()} as parenthesis pairs.

\begin{lstlisting}[
  language=c++,
  caption=\gls{tml} parser implementation,
  label=lst:tml-parser
]{}
/// Parses a TML formula to RPN.
constexpr shunting_yard::parse_result_t
parse(std::string_view const &formula) {
  namespace sy = shunting_yard;

  // Defining various tokens
  sy::token_specification_t tiny_math_language_spec{
      .variables =
          {
              sy::variable_t("x"),
              sy::variable_t("y"),
          },
      .functions =
          {
              sy::function_t("sin"),
              sy::function_t("max"),
          },
      .operators =
          {
              sy::operator_t("+", sy::left_v, 10),
              sy::operator_t("-", sy::left_v, 10),
              sy::operator_t("*", sy::left_v, 20),
              sy::operator_t("/", sy::left_v, 20),
              sy::operator_t("^", sy::right_v, 30),
          },
      .lparens = {sy::lparen_t("("),
                  sy::lparen_t("{")},
      .rparens = {sy::rparen_t(")"),
                  sy::rparen_t("}")}};

  // Running the Shunting yard algorithm
  // with the TML language specification
  return parse_to_rpn(formula,
                      tiny_math_language_spec);
}
\end{lstlisting}

Using the Sunting Yard implementation from
appendix \ref{app:shunting-yard-impl}, we can specify variable identifiers,
function identifiers, infix operators (with precendence), and parenthesis
as shown in listing \ref{lst:tml-parser} to define a simple math language
that can be parsed by a \gls{constexpr} function.

We will now oversee the code generation implementation.
As a quick reminder, generating code from a \gls{rpn} formula
consists in reading tokens one by one, stacking operands, and consuming
them as needed. The stack is implemented with a \lstinline{kumi::tuple} object,
which is an enhanced version of \lstinline{std::tuple}.

\begin{lstlisting}[
  language=c++,
  caption=\gls{tml} operand examples,
  label=lst:tml-operands
]{}
/// Operand representing the 42 constant
auto forty_two = [](auto const &, auto const &) {
  return 42;
};

/// Operand representing the x variable
auto x = [](auto const &input_x,
            auto const &) -> auto const & {
  return input_x;
};

// Note: We assume operand_a and operand_b
// are operands we consumed from the stack.

/// Operand representing the plus operator
auto plus = [operand_a,
             operand_b](auto const &input_x,
                        auto const &input_y) {
  return operand_a(input_x, input_y) +
         operand_b(input_x, input_y);
};
\end{lstlisting}

Each operand in the tuple is a function that takes \lstinline{x} and
\lstinline{y} parameters and returns an arbitrary value.
As such, operands have a form similar to the function
objects shown in listing \ref{lst:tml-operands}.
The parameters are not used by the \lstinline{forty_two} operand,
the \lstinline{x} operand simply forwards the first parameter,
and the \lstinline{plus} operand forwards the parameters to its sub-operands.

The result of the code generation is a function that takes two elements of
arbitrary type as an input, and performs the operations on them.

\begin{lstlisting}[
  language=c++,
  caption=\gls{tml} usage example,
  label=lst:tml-usage
]{}
int main() {
  namespace tml = tiny_math_language;

  static constexpr auto formula =
      "sin((x + 3) / 3 * y ^ 2)";

  // Runtime parsing prints parsing steps
  // for debugging
  tml::parse(formula);

  // Input vectors
  constexpr std::size_t vec_size = 16;
  blaze::DynamicVector<double> vector_x(vec_size, 1.),
      vector_y(vec_size, 12.);

  // Generating code from the formula
  auto function = tml::codegen<formula>();

  // Running the generated code
  blaze::DynamicVector<double> result =
      function(vector_x, vector_y);

  // Printing and verifying the result
  double const expected_value =
      std::sin((1. + 3.) / 3. * std::pow(12., 2.));
  for (double const &element : result) {
    fmt::println("{}", element);
    if (std::abs(element - expected_value) > 0.01) {
      throw;
    }
  }
}
\end{lstlisting}

Listing \ref{lst:tml-usage} shows how to generate code from a formula
and use the generated function to perform operations on Blaze vectors.
We use this code to verify the validity of the result.

\begin{lstlisting}[
  language=c++,
  caption=Result type checking for generated function output,
  label=lst:tml-blaze-typecheck
]{}
using namespace blaze;

using expected_type = DVecMapExpr<
    DVecScalarMultExpr<
        DVecDVecMultExpr<
            DVecMapExpr<
                DynamicVector<
                    float, false,
                    AlignedAllocator<float>,
                    GroupTag<0>>,
                Bind2nd<Add, float>, false>,
            DVecMapExpr<
                DynamicVector<
                    float, false,
                    AlignedAllocator<float>,
                    GroupTag<0>>,
                Bind2nd<Pow, float>, false>,
            false>,
        float, false>,
    Sin, false>;

static_assert(std::is_same<
              expected_type,
              decltype(function(
                  vector_x, vector_y))>::value);
\end{lstlisting}

We also verify that the expression \lstinline{function(vector_x, vector_y)}
generates the right Blaze expression template by compiling the code in
listing \ref{lst:tml-blaze-typecheck}. The \lstinline{static_assert}
expression will not compile if the generated type is not the same as
\lstinline{expected_type}.

\subsection{
  Studying the compilation time overhead of parsing
  for high performance code generation
}

A question remains about the use of compile time math parsing
for high performance code generation: what is the compilation time impact?
To answer that question, I will again measure compilation times for benchmarks
representing what would be a "realistic" use case in terms of size,
and simpler synthetic benchmarks to study the scaling of the
performance overhead as math formula sizes increase.

% A "realistic" use case

For the "realistic" use case, we will simply consider the formula from
listing \ref{lst:tml-usage} and measure the compiler execution time
with and without compile time parsing to generate a Blaze expression.
In one measurement where we compile a \gls{tml} formula into its evaluation
via Blaze, we observe a compilation time of 5.94 seconds.
In another one where we compile the same formula using the Blaze API directly
and without including the \gls{tml} header, the measured compilation time is
5.62 seconds.

These initial measurements show that a 6\% compile time overhead when using
the \gls{tml} parser on top of Blaze.
However a larger sample might

\begin{lstlisting}[
  language=c++,
  caption=Benchmark case: Blaze with \gls{tml} parsing,
  label=lst:blaze-bench-with-tml
]{}
#include <boost/preprocessor/repetition/repeat.hpp>
#include <blaze/Blaze.h>
#include <tiny_math_language.hpp>

// Generating a series of additions
#define REPEAT_STRING(z, n, str) str
static constexpr const char *program_string =
    BOOST_PP_REPEAT(BENCHMARK_SIZE, REPEAT_STRING,
                    "x + y + ") "x";

/// Benchmark entry point.
template <typename T = void> inline auto bench_me() {
  blaze::DynamicVector<unsigned int> vector_a(32, 12);
  blaze::DynamicVector<unsigned int> vector_b(32, 12);

  blaze::DynamicVector<unsigned int> res =
      tiny_math_language::codegen<program_string>()(
          vector_a, vector_b);

  return res;
}

void foo() { bench_me(); }
\end{lstlisting}

\begin{lstlisting}[
  language=c++,
  caption=Benchmark case: Blaze without \gls{tml} parsing,
  label=lst:blaze-bench-without-tml
]{}
template <typename T = void> inline auto bench_me() {
  blaze::DynamicVector<unsigned int> vector_a(32, 12);
  blaze::DynamicVector<unsigned int> vector_b(32, 12);

  blaze::DynamicVector<unsigned int> res =
      BOOST_PP_REPEAT(BENCHMARK_SIZE, REPEAT_STRING,
                      vector_a + vector_b +) vector_a;

  return res;
}
\end{lstlisting}

Listing \ref{lst:blaze-bench-without-tml}

\begin{figure}[h]
% \fontsize{8}{10}\selectfont
\includesvg[width=\textwidth]{images/shunting-yard.addition-series}
\caption{Code generation parsing benchmarks}
\end{figure}

\subsection{
  Conclusion: a complete toolchain for high performance code generation
  from math formulas
}



\end{document}
