\documentclass[../../main.tex]{subfiles}

\begin{document}

% - SotA metaprog (Can't read)
%   - C++ (Can't read)
%   - Reflection
%   - Can't read

\chapter{Introduction}

This thesis is about metaprogramming techniques for parallel code generation.
It aims to study the boundary between compile-time parsing of
domain-specific embedded languages and high performance code generation in \cpp.

The main motivation is to provide tools, libraries, and guidelines for embedding
mathematical languages in \cpp with the hope that it can be useful to build a
cohesive set of tools to make generic high performance computing more accessible
to non-specialized audiences. This goal is even more important as new computing
architectures emerge over time. Developing high performance programs requires
specialized implementations that can be achieved by either specializing
implementations, or using libraries that provide specialized abstractions at
various levels and for various domains.

\chapter{State of the art of metaprogramming}

In this state of the art I will first give an overview of metaprogramming in
historic and contemporary languages. Then I will focus on the state of the art
of \cpp metaprogramming, and notable high performance computing libraries as they
are essential for the scope of my thesis.

\section{Metaprogramming styles and languages}

\subsection{A short history of metaprogramming}

\subsection{Metaprogramming in contemporary languages}

Metaprogramming perpetuates itself in contemporary languages,
with some being more widespread than others.

\paragraph{MetaOCaml}

MetaOCaml\cite{metaocaml} implements quoting and splicing
\ie the ability to essentially copy and paste expressions,
as well as staged compilation to evaluate statements at compile-time.
This enables code generation to occur both at runtime and at compile-time.

\paragraph{DLang}

DLang more or less extends the metaprogramming model accidentally proposed
by \cpp. It leverages templates and compile time function evaluation just like
its predecessor, but with a much more permissive approach than its predecessor.


\paragraph{Rust}

Rust proposes metaprogramming through generics, macros and traits.
Generics are similar to \cpp templates, although

\paragraph{Braid}

\paragraph{Terra}

Terra\cite{terra} implements a very explicit metaprogramming model.
The language is based on LUA, and exploits the dynamic nature of the language
together with LLVM JIT compilation to allow code generation
to happen at runtime.
It implements multi-staged compilation and splicing just like MetaOCaml.

Additionally, Terra can be embedded in other languages through its C API.
Overall it is a very versatile and experimental take on metaprogramming,
but the lack of interoperability with \cpp templates makes it hard to justify
its use for HPC applications.

As we will see in section \ref{lbl:meta-cpp}, GPU computing libraries
rely heavily on \cpp metaprogramming to provide building blocks for
portable high performance compute kernels.

\section{Metaprogramming and HPC in C++} \label{lbl:meta-cpp}

\subsection{Language constructs of C++ metaprogramming}

Metaprogramming in \cpp relies on

\paragraph{Templates}

\paragraph{Overloading}

\paragraph{Parameter packs}

\paragraph{Constexpr functions and variables}

\subsection{Core and application-specific libraries}

As previously said \cpp templates can be seen as a functional language.
Over time a range of libraries emerged, aiming to provide functionalities
similar to regular language such as containers and algorithms for use in
template metaprograms. Notable examples of such libraries are MPL\cite{mpl},
Brigand\cite{brigand}, and mp11\cite{mp11}.

Libraries for more specific uses were also implemented, such as
Spirit\cite{spirit} for writing parsers (not for compile time parsing),
Compile Time Regular Expressions (CTRE)\cite{ctre}
for compiling regular expressions,
and Compile Time Parser Generator(CTPG)\cite{ctpg}
for generating LR1 parsers (also not for compile time parsing).

The advertised benefits of metaprogrammed libraries are:

\begin{itemize}

\item Performance: notably in the case of CTRE.
Regular expressions are usually interpreted at runtime.
It shows performance on par with Rust's regex library
which also achieves leading performance levels
by compiling regular expressions.

\item Language integration: since these are \cpp libraries,
their APIs can take advantage of \cpp operator overloading and lambdas.
In CTPG, these are used to provide a domain-specific language that is close to
what parser generators like YACC or Bison provide,
though it is still regular \cpp code which can be put inside any function body.
Using a \cpp API makes these libraries easier to learn
as the syntax is already familiar to their users.

\item Streamlined toolchain: as they only require to be included as headers.
This avoids complicating compilation toolchains by requiring additional programs
to be installed and integrated to the build system.

\end{itemize}

\subsection{High performance computing libraries}

Eigen

Blaze

NT2

EVE

HPX

Thrust, CUB, etc.

\section{Conclusion}

\begin{itemize}
\item Metaprogramming isn't a new idea

\item Some languages provide advanced metaprogramming capabilities

\item \cpp has solid metaprogramming constructs, and a complete HPC ecosystem
(libraries, compilers, etc.)
\end{itemize}

\end{document}
