\documentclass[../../main.tex]{subfiles}

\begin{document}

\chapter{Code generation at low level}

\subfile{hpcs-paper-rewrite.tex}

\chapter{Blaze: code generation at expression level}

In this chapter I will cover the use of template metapramming for higher levels
of abstraction. Templates can be used to represent whole mathematical
expressions at compile time by creating type arborescences where internal
nodes represent operations, and leaves are the operands. This type of
representation is called an expression template\cite{veldhuizen:1995}.

Combined with compile-time mechanisms such as function overloading,
specialization, and operator overloading, expression templates can be used to
implement expression level \dsels and convert large mathematical expressions
into high performance code.

There are two main libraries that are able to do just this: Eigen\cite{eigen}
and Blaze\cite{blazelib}.



How do they work?

Your math expressions aren't represented by structures,
they're represented by types.

You don't use conditions at runtime but overloading at compile time.

Enables a whole range of optimizations:

\begin{itemize}
\item Lazy evaluation
\item Fused operations using BLAS
\item Eventually: GPU code generation, although Blaze needs a significant
      rewrite for that. Source rewriting tools might be a good fit for that job.
\end{itemize}

Expression templates can provide expression level APIs for HPC libraries.

Still two limitations:

\begin{itemize}
\item Slow compilation times
\item \cpp syntax only
\end{itemize}

Expression templates are aging (pretty well but still).
Newer \cpp standards provide metaprogramming features that can fundamentally
change the way we write metaprograms.

The next part of my thesis will focus on how to leverage these features to
implement \dsel of arbitrary syntax, and the study of their impact on
compilation times.

\end{document}
