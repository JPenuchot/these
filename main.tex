%%%% Modèle proposé par kira.ribeiro@universite-paris-saclay.fr  %%%%
%%%% màj : 27/01/2023 %%%%

\documentclass[english,12pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[default,oldstyle, scale=.95]{opensans} % police Open Sans
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{csquotes}
\usepackage{caption}
\captionsetup[figure]{font=small,labelfont=small}
\usepackage{xcolor} % ou color selon l'installation
\definecolor{Prune}{RGB}{99,0,60} % l14-33 : couleurs de la charte graphique upsaclay
\definecolor{B1}{RGB}{49,62,72}
\definecolor{C1}{RGB}{124,135,143}
\definecolor{D1}{RGB}{213,218,223}
\definecolor{A2}{RGB}{198,11,70}
\definecolor{B2}{RGB}{237,20,91}
\definecolor{C2}{RGB}{238,52,35}
\definecolor{D2}{RGB}{243,115,32}
\definecolor{A3}{RGB}{124,42,144}
\definecolor{B3}{RGB}{125,106,175}
\definecolor{C3}{RGB}{198,103,29}
\definecolor{D3}{RGB}{254,188,24}
\definecolor{A4}{RGB}{0,78,125}
\definecolor{B4}{RGB}{14,135,201}
\definecolor{C4}{RGB}{0,148,181}
\definecolor{D4}{RGB}{70,195,210}
\definecolor{A5}{RGB}{0,128,122}
\definecolor{B5}{RGB}{64,183,105}
\definecolor{C5}{RGB}{140,198,62}
\definecolor{D5}{RGB}{213,223,61}

\usepackage[absolute]{textpos}
\usepackage{array}
\usepackage{biblatex}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{geometry}
\usepackage{glossaries}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{mdframed}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{subcaption}
\usepackage{svg}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{xspace}

% \renewcommand{\FrenchLabelItem}{\textbullet}

% pour ne garder que les n°de page en milieu-bas
% et supprimer les indications de chapitre en marge haute
\pagestyle{plain}

% Fichiers biblio

\addbibresource{bibliography/biblio.bib}
\addbibresource{bibliography/comptime.bib}
\addbibresource{bibliography/ctbench.bib}
\addbibresource{bibliography/hpcs2018.bib}
\addbibresource{bibliography/metalanguages.bib}
\addbibresource{bibliography/metalibraries.bib}
\addbibresource{bibliography/poacher.bib}
\addbibresource{bibliography/simd.bib}

% Commandes pour la these de Jules

\providecommand{\cpp}{\textsc{C++}\xspace}
\providecommand{\ctbench}{\textsc{ctbench}\xspace}
\providecommand{\eg}{\textit{e.g.}\xspace}
\providecommand{\grapher}{\textsc{grapher}\xspace}
\providecommand{\ie}{\textit{i.e.}\xspace}

\hypersetup{
  colorlinks=true, % toujours garder colorlinks=true
  linkcolor=black,
  urlcolor=A5
}

\lstset{
  frame=single,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{C1},
  keywordstyle=\color{B2},
  commentstyle=\color{D4},
  stringstyle=\color{A3},
  breaklines=true,
  tabsize=2,
  showstringspaces=false
}

\lstdefinelanguage{cmake}{
  morekeywords={STRING, BOOL, CACHE, REQUIRED},
  morecomment=[l]{\#},
  morestring=[b]"
}

\lstdefinelanguage{javascript}{
  morekeywords={},
  morecomment=[l]{},
  morestring=[b]"
}

\lstdefinelanguage{json}{
  morekeywords={},
  morecomment=[l]{},
  morestring=[b]"
}

\makeglossaries

\newglossaryentry{litval}{
  name=literal value,
  plural=literal values,
  description=A value that does not hold any pointer to dynamic memory.
}

\newglossaryentry{constexpr}{
  name=\lstinline{constexpr},
  description=A value or function that can be used in a constant expression.
}

\newglossaryentry{consteval}{
  name=constant evaluation,
  plural=constant evaluations,
  description=The evaluation of an expression that is performed at compile time.
}

\newacronym{ast}{AST}{Abstract Syntax Tree}
\newacronym{bf}{BF}{Brainfuck}
\newacronym{cpu}{CPU}{Central Processing Unit}
\newacronym{ctpg}{CTPG}{Compile Time Parser Generator}
\newacronym{ctre}{CTRE}{Compile Time Regular Expression}
\newacronym{dsel}{DSEL}{Domain Specific Embedded Language}
\newacronym{dsl}{DSL}{Domain Specific Language}
\newacronym{et}{ET}{Expression Template}
\newacronym{gpu}{GPU}{Graphical Processing Unit}
\newacronym{hpc}{HPC}{High Performance Computing}
\newacronym{jit}{JIT}{Just-In-Time}
\newacronym{nttp}{NTTP}{Non-Type Template Parameter}
\newacronym{pbg}{PBG}{pass-by-generator}
\newacronym{pcre}{PCRE}{Perl Compatible Regular Expression}
\newacronym{rpn}{RPN}{Reverse Polish Notation}
\newacronym{sfinae}{SFINAE}{Substitution Failure Is Not An Error}
\newacronym{simd}{SIMD}{Single Instruction Multiple Data}
\newacronym{tmp}{TMP}{Template Metaprogramming}

% ==============================================================================
\usepackage{subfiles} % Garder a la fin

\begin{document}

\begin{titlepage}

%\thispagestyle{empty}

\newgeometry{left=6cm,bottom=2cm, top=1cm, right=1cm}

\tikz[remember picture,overlay]
\node[opacity=1,inner sep=0pt] at (-13mm,-135mm){
  \includegraphics{ups/frame.pdf}
};

%*****************************************************
%******** NUMÉRO D'ORDRE DE LA THÈSE À COMPLÉTER *****
%******** POUR LE SECOND DÉPOT                   *****
%*****************************************************

\color{white}

\begin{picture}(0,0)
\put(-152,-743){\rotatebox{90}{\Large \textsc{THESE DE DOCTORAT}}} \\
\put(-120,-743){\rotatebox{90}{NNT : 2020UPASA001}}
\end{picture}

%*****************************************************
%******************** TITRE **************************
%*****************************************************

\flushright
\vspace{10mm} % à régler éventuellement
\color{Prune}

\fontsize{22}{26}\selectfont
  \Huge Techniques avanc\'ees de g\'en\'eration de code pour le parall\'elisme\\

\normalsize
\color{black}
\Large{\textit{Advanced techniques for parallel code generation}} \\
%*****************************************************


\fontsize{8}{12}\selectfont

\vspace{1.5cm}

\normalsize
\textbf{Thèse de doctorat de l'université Paris-Saclay} \\

\vspace{6mm}

% TODO
\small École doctorale n$^{\circ}$ d'accréditation, dénomination et sigle\\
\small Spécialité de doctorat: voir annexe\\
\small Graduate School : voir annexe. Référent : voir annexe \\
\vspace{6mm}

% TODO: Verifier l'unite de recherche
\footnotesize Thèse préparée dans la (ou les) unité(s) de recherche
\textbf{STIC} (voir annexe), sous la direction de \textbf{Joel FALCOU},
titre du directeur ou de la directrice de thèse \\
\vspace{15mm}

\textbf{Thèse soutenue à Paris-Saclay, le JJ mois AAAA, par}\\
\bigskip
\Large {\color{Prune} \textbf{Jules P\'ENUCHOT}} % Changer le Prénom et le NOM

%************************************
\vspace{\fill} % ALIGNER LE TABLEAU EN BAS DE PAGE
%************************************

\bigskip

\flushleft
\small {\color{Prune} \textbf{Composition du jury}}\\
{\color{Prune} \scriptsize {Membres du jury avec voix délibérative}} \\
\vspace{2mm}
\scriptsize
\begin{tabular}{|p{7cm}l}
\arrayrulecolor{Prune}
\textbf{Prénom NOM} &   Président ou Présidente\\
Titre, Affiliation & \\
\textbf{Prénom NOM} &  Rapporteur \& Examinateur / trice \\
Titre, Affiliation   &   \\
\textbf{Prénom NOM} &  Rapporteur \& Examinateur / trice \\
Titre, Affiliation  &   \\
\textbf{Prénom NOM} &  Examinateur ou Examinatrice \\
Titre, Affiliation   &   \\
\textbf{Prénom NOM} &  Examinateur ou Examinatrice \\
Titre, Affiliation   &   \\

\end{tabular}

\end{titlepage}

% page des résumés à garder en 2ème page.
% Si les résumés sont trop longs pour tenir sur une seule et même page,
% on peut mettre un résumé par page
\thispagestyle{empty}
\newgeometry{top=1.5cm, bottom=1.25cm, left=2cm, right=2cm}

\noindent
\includegraphics[height=2.45cm]{ups/logo_STIC.png}
\vspace{1cm}
%*****************************************************

\small

\begin{mdframed}[linecolor=Prune,linewidth=1]

\textbf{Titre:} Techniques avanc\'ees de g\'en\'eration de code pour le
parall\'elisme

\noindent \textbf{Mots clés:} M\'etaprogrammation, compilation, C++ % TODO

\vspace{-.5cm}
\begin{multicols}{2}
\noindent \textbf{Résumé:} Mettre le sum ici % TODO
\end{multicols}

\end{mdframed}

\vspace{8mm}

\begin{mdframed}[linecolor=Prune,linewidth=1]

\textbf{Title:} Advanced techniques for parallel code generation

\noindent \textbf{Keywords:} Metaprogramming, compilation, C++ % TODO

\begin{multicols}{2}
\noindent \textbf{Abstract:} Mettre l'abstract ici % TODO
\end{multicols}
\end{mdframed}

\titleformat{\chapter}[hang]{\bfseries\Large\color{Prune}}{\thechapter\ -}{.1ex}
{\vspace{0.1ex}}[\vspace{1ex}]\titlespacing{\chapter}{0pc}{0ex}{0.5pc}

\titleformat{\section}[hang]{\bfseries\normalsize}{\thesection\ .}{0.5pt}
{\vspace{0.1ex}}[\vspace{0.1ex}]\titlespacing{\section}{1.5pc}{4ex plus .1ex minus .2ex}{.8pc}

\titleformat{\subsection}[hang]{\bfseries\small}{\thesubsection\ .}{1pt}
{\vspace{0.1ex}}[\vspace{0.1ex}]\titlespacing{\subsection}{3pc}{2ex plus .1ex minus .2ex}{.1pc}

\newgeometry{top=4cm, bottom=4cm, left=2cm, right=2cm}

\tableofcontents

\newgeometry{top=4cm, bottom=4cm, left=4cm, right=4cm}

% ------------------------------------------------------------------------------
% Commandes pour la these de Jules

% ------------------------------------------------------------------------------
% These de Jules

\part{Current state of metaprogramming for high performance computing}

\chapter{
  Introduction
}

This thesis is about metaprogramming techniques for parallel code generation.
It aims to study the boundary between compile-time parsing of
\glspl{dsel} and high performance code generation in \cpp.

The main motivation is to provide tools, libraries, and guidelines for embedding
mathematical languages in \cpp with the hope that it can be useful to build a
cohesive set of tools to make generic \gls{hpc} more accessible
to non-expert audiences. This goal is even more important as new computing
architectures emerge over time. Developing high performance programs requires
tuned implementations that can be achieved by either specializing
implementations for the target platforms, or using libraries that provide
specialized abstractions at various levels and for various domains.

\chapter{
  State of the art of Metaprogramming
}

\subfile{1-current-metaprogramming/metaprog-and-hpc-overview.tex}
\subfile{1-current-metaprogramming/cpp-constructs.tex}

\chapter{
  Code generation at low level
}

\subfile{1-current-metaprogramming/low-level.tex}

\chapter{
  Code generation at expression level
}

\subfile{1-current-metaprogramming/expression-level.tex}

\part{C++ metaprogramming beyond templates}

\chapter{
  Establishing a methodology for compile time benchmarking
}

With \gls{tmp} libraries like Eigen\cite{eigen}, Blaze\cite{blazelib},
or CTRE\cite{ctre} becoming larger and more common,
we're seeing increasing computing needs at compile time. These needs might grow
even larger as \cpp embeds more features over time to support and extend this
kind of practices, like compile time containers\cite{more-constexpr-containers}
or static reflection\cite{static-reflection}. However, there is still no clear
cut methodology to compare the performance impact of different metaprogramming
strategies. But as new \cpp features allow for new techniques with claimed
better compile time performance, no proper methodology is provided to back up
those claims.

In this chapter I introduce \ctbench, which is a set of tools for compile time
benchmarking and analysis in \cpp. It aims to provide developer-friendly tools
to declare and run benchmarks, then aggregate, filter out, and plot the data to
analyze it. As such, \ctbench is meant to become the first layer of a proper
scientific methodology for analyzing compile time program behavior.

We'll first have a look at current tools for compile time profiling and
benchmarking and establish the limits of current tooling, then I'll explain
what \ctbench brings to overcome these limits.

\ctbench was first presented at the CPPP 2021 conference\cite{ctbench-cppp21}
which is the main \cpp technical conference in France. It is being used to
benchmark examples from the poacher\cite{poacher} project, which was briefly
presented at the Meeting \cpp 2022\cite{meetingcpp22} technical conference.

\subfile{2-compilation-time-analysis/state-of-the-art.tex}
% \subfile{2-compilation-time-analysis/features-and-design.tex}
\subfile{2-compilation-time-analysis/ctbench-design.tex}
\subfile{2-compilation-time-analysis/ctbench-in-action.tex}

\section{Related projects} % TODO: Rework

\begin{itemize}

\item Poacher (https://github.com/jpenuchot/poacher): Experimental constexpr
      parsing and code generation for the integration of arbitrary syntax DSL in
      \cpp20

\item Rule of Cheese (https://github.com/jpenuchot/rule-of-cheese):
      A collection of compile time microbenchmarks to help set better
      \cpp metaprogramming guidelines to improve compile time performance
\end{itemize}

\section{Acknowledgements}

We acknowledge contributions from Philippe Virouleau and Paul Keir for their
insightful suggestions.

\chapter{
  Constexpr parsing for high performance computing
}
% \begin{abstract}
% Design of high performance, high abstraction libraries in \cpp often take
% advantages of techniques like template metaprogramming or \glspl{et}
% to design \glspl{dsel}. However, such techniques are limited by the natural syntax
% of \cpp. In this thesis, we explore the benefits of using \cpp23 compile time
% computation features to provide compile time string based \glspl{dsel} that can then
% use arbitrary syntax.
% \end{abstract}

\section{Introduction}

\cpp is often touted as a \textit{Zero-Cost Abstraction} langage due to some of
its design philosophy and its ability to compile abstraction to a very efficient
binary code. Some more radical techniques can be used to force the compiler to
interpret \cpp code as a \gls{dsel}. \Gls{tmp} is such a technique
and it spawned a large corpus of related idioms from compile time function
evaluation to lazy evaluation via \glspl{et}.

In the field of High Performance Computing, \cpp users are often driven to use
libraries built on top of those idioms like Eigen\cite{eigen} or
Blaze\cite{blazelib,iglberger2012_2}. They all suffer from a major limitation:
by being tied to the natural \cpp syntax, they can't express nor embed arbitrary
languages.

In this thesis, we try to demonstrate that the new features of \cpp23 related to
compile time programming are able to help developers designing \glspl{dsel} with
arbitrary syntax by leveraging \gls{constexpr} computations, compile time dynamic
objects and lazy evaluation through lambda functions. After contextualizing our
contribution in the general \glspl{dsel} domain, this thesis will explain the core
new techniques enabled by \cpp23 and how we can apply to build two different
\glspl{dsel} with their own non-\cpp syntax. We'll also explore the performances of
said \glspl{dsel} in term of compile time to assess their usability in realistic code.

\subfile{3-new-approaches-to-metaprogramming/1-technical-background.tex}
\subfile{3-new-approaches-to-metaprogramming/2-constexpr-codegen-techniques.tex}
\subfile{3-new-approaches-to-metaprogramming/3-brainfuck.tex}
\subfile{3-new-approaches-to-metaprogramming/4-math-parsing.tex}

\section{Conclusion}

% [TODO] Talk about how pass-by-generator actually kinda sucks
% because of constexpr constraints, and how serializing takes more code
% but less time debugging stuff related to constexpr constraints.
% Serializing makes dealing with dynamic memory easier because codegen functions
% only deal with static memory.

We wanted to demonstrate that using \gls{constexpr} code to implement parsers for
\gls{dsel} of arbitrary syntax in \cpp23 is possible despite limitations on
\gls{constexpr} memory allocation, and that doing so is possible with reasonable
impact on compilation times.

We achieved that by implementing a \gls{constexpr} parser for the Brainfuck language,
with code generation backends implementing three different strategies to
transform \gls{constexpr} program representations into code using function
generators, \glspl{et}, and non-type template parameters.
We also demonstrated the interoperability of these \gls{constexpr} parsers by
implementing a parser for mathematical languages that can be used as a frontend
for existing high performance \cpp computation libraries.

Our benchmarks highlight compilation time scaling issues with pass-by-generator
and \gls{et} code generation strategies for large programs, and
excellent scaling capabilities for non-type template parameter based code
generation strategies. These results can be used to decide which strategy to
adopt for the implementation of future \gls{dsel} based on \gls{constexpr} parsers
based on considerations for compilation times or implementation complexity.

Going forward, \gls{constexpr} parser generators could help reduce
\gls{dsel} implementation time and help embed more languages into \cpp23.
Further research has to be made to determine the impact of such generators on
\gls{dsel} implementation complexity and compilation times.

% On avait tel objectif X et Y
% On montre qu'on a fait X et que ca permet Y
% Les benchmarks montrent la pluvalue avec un temps de compil raisonnable
% Nos travaux futurs: AI deep learning blockchain

% TODO: Talk about Cest

\clearpage

\printglossaries

\clearpage
\printbibliography

\chapter{Appendix}

\appendix

\subfile{3-new-approaches-to-metaprogramming/appendix.tex}

\end{document}
